#!/bin/bash
# vim: noexpandtab:ts=4:sw=4
DUAL_BOOT_DIR="/usr/share/dualboot"
# Stop executing the script on error
set -e

. $DUAL_BOOT_DIR/fydeos_util.sh

flog_init
#### Print usage help text and exit
print_usage() {
	echo "Usage: $0 -d | --dst <target disk device>

The system must boot in UEFI mode. The target disk must be using GPT partition table, have a EFI system partition, and have at least 8GB of free space.

For the safety of your data, this scrpit NEVER remove any existing partition. You have to make free space for Flin OS by yourself.

On Mac, the Disk Utility tool does not leave spare space on disk when you shrink existing partition, instead they always create an \"Untitled\" partition. You have to remove that \"Untitled\" partition first to release its space."
	exit
}

#### All pre-installation checkes
precheck() {
	precheck_system
	precheck_part_table
	precheck_esp
	precheck_space
}

# Check whether system meets requirement, such as EFI
precheck_system() {
	if [[ ! -d /sys/firmware/efi ]]; then
		die "This script currently support UEFI system only, your system either does not support UEFI or is not boot in UEFI mode."
	fi
}

# Check whether disk parition type meets requirement
precheck_part_table() {
	if [[ -z "$(gdisk -l $target_disk | grep 'GPT: present')" ]]; then
		die "This script currently supports GPT partitioned disk only."
	fi
}

precheck_esp() {
	local espdev=$(find_esp_dev)

	if [[ -z ${espdev} ]]; then
		die "There is no EFI system partition on disk. To run FydeOS your disk must have one."
	else
		local mntpt=$(mktemp -d -p /tmp fydeos.XXXXXX)

		if mount $espdev $mntpt; then
			local free=$(findmnt -o avail -b -n $mntpt)
			umount $mntpt
            rmdir $mntpt
			if [[ $free -lt $(( 1 * 1024 * 1024 )) ]]; then
				die "EFI system partition $espdev free space is less than 1MB, aborting..."
			fi
		else
			die "Failed to mount EFI system partition $espdev, is it corrupted?"
		fi
	fi
}

# Check disk spare space
precheck_space() {
    if [[ -z "$(find_fydeos_root)" || -z "$(find_fydeos_state)" ]]; then
        flog "New install..."
        local free_sector_start=$(sgdisk -F $target_disk)
        local free_sector_end=$(sgdisk -E $target_disk)
        local free_sectors=$(($free_sector_end - $free_sector_start))

        if [[ $free_sectors -lt $(( 8 * 1024 * 1024 * 1024 / 512)) ]]; then
            die "Disk free space is less than 8GB, abort."
        fi
    else
        flog "Old FydeOS found, check partitions for update"
        local root=$(find_fydeos_root)        
        if [[ $(get_target_sectors $root) -lt $(get_rootfs_sectors) ]]; then
            flog "The old FydeOS partition is smaller than the new version"
            die "Please delete all old partitions for new installation. "
        fi
    fi
}

#### Print disk information for user review
printcfg() {
	flog "Will install FydeOS to disk $target_disk."
	echo -e "Current partitions:\n\n$(fdisk -l $target_disk)\n\n"
}

#### Ask if user would like to proceed
userconfirm() {
	# Ask for confirmation before start to install
	flog "This will install FydeOS to $target_disk."
	flog "No existing partition will be removed, a few new paritions will be created."
	flog -e "\nPlease confirm you are aware of the risks of losing data during the process and have made necessary backup.\n"

	local sure
	read -p "Are you sure to proceed (y/N)? " sure
	if [[ "${sure}" != "y" ]]; then
		echo -e "\nYou have chosed to not install, exiting..."
		return 1
	fi
}

#### All installation tasks
install() {
	install_mkpart
	discover_part_devs
	discover_part_nums
	install_rootfs
	install_stateful
	install_bootmgr
}

find_fydeos_root() {
    find_partition_by_label $FYDEOS_ROOT_LABEL $target_disk
}

find_fydeos_state() {
    find_partition_by_label $FYDEOS_STATE_LABEL $target_disk
}

create_rootfs() {
    if [ -z "$(find_fydeos_root)" ]; then
        sgdisk -a 2048 -n 0:0:+$(get_rootfs_sectors) -t 0:3CB8E202-3B7E-47DD-8A3C-7FF2A13CFCEC -c 0:$FYDEOS_ROOT_LABEL $target_disk
        flog "FydeOS root partition created."
    fi
}

create_statefs() {
    if [ -z "$(find_fydeos_state)" ]; then
        sgdisk -a 2048 -n 0:0:0 -t 0:EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 -c 0:$FYDEOS_STATE_LABEL $target_disk
        flog "FydeOS state partition created."
    fi
}
# Create partitions
install_mkpart() {
	# Stop CrOS disk mounting daemon first. It may operate on disks in the background thus could
	# interfere with below partition operations. No proof yet, just in case.
	flog $(initctl stop cros-disks)

	flog "Creating/Check partitions on target disk $target_disk"
    create_rootfs
    create_statefs
	# Re-read parition table, yeah this is dirty.
    until blockdev --rereadpt $target_disk >null 2>&1;
    do
        sleep 2
    done
    flog "All paritions are created."
	# Re-start the disk mounting daemon
	flog $(initctl start cros-disks)
}

# Install rootfs to disk
install_rootfs() {
	flog "Installing root filesysteem on $root_a_dev ..."
	dd if=$boot_rootdev of=$root_a_dev bs=1M status=progress
	config_rootfs $root_a_dev
}

prepare_state_fs() {
    if ! is_ext4_exist $state_dev; then
        umount -f $state_dev > /dev/null 2>&1 || true
        mkfs.ext4 -O encrypt -F -b 4096 $state_dev
    fi
    sync_label $state_dev     
}

# Install stateful parition to disk
install_stateful() {
	flog "Install stateful files into $state_dev..."

	# umount it first in case it already has a fs and automounted by the running OS

    prepare_state_fs
	# Copy over files on stateful partition: dev_image, var_overlay, vmlinuz_hd.vblock
	local source_state=/mnt/stateful_partition
	local target_state=$(mktemp -d -p /tmp fydeos.XXXXXX)

	[[ -d ${target_state} ]] || mkdir ${target_state}
	mount $state_dev ${target_state}

	flog "Copying over necessary files to the new stateful partition..."
	[[ -f ${source_state}/vmlinuz_hd.vblock ]] && cp ${source_state}/vmlinuz_hd.vblock ${target_state}
	[[ -d ${source_state}/dev_image ]] && cp -a ${source_state}/dev_image ${target_state}
	[[ -d ${source_state}/var_overlay ]] && cp -a ${source_state}/var_overlay ${target_state}

	umount ${target_state}
    rmdir ${target_state}
}

# Install  boot loader
install_efi_fydeos() {
    local target_dir=$1/efi/fydeos
    local source_dir=$DUAL_BOOT_DIR/fydeos
    [ -d $target_dir ] || mkdir -p $target_dir
    cp $source_dir/bootx64.efi $target_dir
    cp $source_dir/os_fydeos.png $target_dir
    sed -e "s/%PARTUUID%/$(get_partuuid $root_a_dev)/g" \
        $source_dir/grub.cfg.tpl > $target_dir/grub.cfg
    flog "Boot loader is installed to /efi/fydeos"
}

#copy to /efi/boot to fit for old pc
install_efi_boot() {
    local target_dir=$1/efi/boot
    local source_dir=$1/efi/fydeos
    if [ -d $target_dir ]; then
        if [ -f $target_dir/bootx64.efi ]; then
            if cmp_files $target_dir/bootx64.efi $source_dir/bootx64.efi ;then
                cp $source_dir/grub.cfg $target/
            fi 
        else
            cp $source_dir/* $target_dir
        fi
    else
        cp -r $source_dir $target_dir
    fi
}

detect_refind() {
    local efi_root=$1
    local refind_icons=$1/efi/refind/icons
    local fydeos_logo=$1/efi/fydeos/os_fydeos.png
    if [ -d $refind_icons ]; then
        cp $fydeos_logo $refind_icons
        flog "rEFInd logo copied."
    else
        flog "no rEFInd found."
    fi
}

install_bootmgr() {
	# Install rEFInd files and GRUB config file
	local mntpt=$(mktemp -d -p /tmp fydeos.XXXXXX)
	if mount $esp_dev $mntpt; then
        install_efi_fydeos $mntpt
        install_efi_boot $mntpt
        detect_refind $mntpt
		umount $mntpt
        rmdir $mntpt
		flog "Boot manager installed successfully."
	else
		die "Mount ESP partion failed, boot manager not installed."
	fi
}

# Setup the rootfs on target disk, including change partition number info and set dual boot flag.
# Since we do dual boot, the partition numbers are no longer the same as standard scheme.
# If we don't modify the system according to the actual layout on disk then OS simply can't boot successfully.
# Parameter: <root partition device>
config_extra_files() {
    local target_root=$1
    cp $DUAL_BOOT_DIR/pre-startup.override $target_root/etc/init
    cp $DUAL_BOOT_DIR/update-engine.override $target_root/etc/init
}

config_rootfs() {
    local rootpart=$1
    local mntpt=$(mktemp -d -p /tmp fydeos.XXXXXX)
    local source_gpt="/usr/sbin/write_gpt.sh"
    local tmp_gpt=$(create_tmp_gpt_conf $source_gpt $target_disk)

    if mount $rootpart $mntpt; then
        cp $tmp_gpt $mntpt$source_gpt
        config_extra_files $mntpt
        umount $mntpt
        rmdir $mntpt
        sync_label $rootpart
    else
        die "Mount root partion failed, root partition $rootpart not modified."
    fi
}

# Return the root device name(e.g. /dev/sda3) of current running OS
get_boot_rootdev() {
	rootdev -s
}

# Return the root device size of current running OS, in sectors
get_rootfs_sectors() {
	partx -s -g -o sectors $boot_rootdev
}

get_target_sectors() {
    partx -s -g -o sectors $1
}

# Return ESP partition device name on target disk
find_esp_dev() {
	cgpt find -t efi $target_disk
}

# Discover partition devices on target disk according to actual layout
# It is called after partitions are created on target disk.
discover_part_devs() {
	root_a_dev=$(find_fydeos_root)
	state_dev=$(find_fydeos_state)
	esp_dev=$(find_esp_dev)
}

# Discover partition numbers on target disk according to actual layout
# It is called after partitions are created on target disk.
discover_part_nums() {
	root_a_num=$(parse_partition_num $root_a_dev)
	state_num=$(parse_partition_num $state_dev)
	esp_num=$(parse_partition_num $esp_dev)
}

#### The entry point for dual boot install
dualboot_install() {
	precheck
	printcfg
	userconfirm
	install
	flog "Installation finished successfully."
}

#### Global vars

# The device name of the target disk
declare target_disk


# The device name of each partition on target disk
declare root_a_dev
declare esp_dev
declare state_dev

# The number of each partitions on target disk
declare -i root_a_num
declare -i state_num
declare -i esp_num

# The rootfs device of current running OS
boot_rootdev=$(get_boot_rootdev)


#### Now it all begins
# Check whether the script is run by root
if [[ $(id -u) -ne 0 ]]; then
	die "You must be root to run this script."
fi


[[ $# -le 1 ]] && print_usage
while [[ $# -gt 1 ]]; do
	opt=$1

	case $opt in
		-d | --dst )
			target_disk=$2
			dualboot_install
			shift
			;;
		* )
			print_usage
			;;
	esac

	shift
done
